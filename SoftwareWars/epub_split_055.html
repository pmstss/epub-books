<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8"/>
    <title>After The Software Wars</title>
    <meta name="AUTHOR" content="Keith Curtis"/>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/><link href="stylesheet.css" type="text/css" rel="stylesheet"/><style type="text/css">
		@page { margin-bottom: 5.000000pt; margin-top: 5.000000pt; }</style></head>
  <body dir="LTR" class="calibre">
<h2 class="calibre2" id="calibre_pb_55"><a name="0.4.Maintainability|outline" id="0.4.Maintainability|outline"></a>
 		<span>Maintainability</span></h2> 	  <i class="calibre5">The major incentive to productivity and efficiency are social and moral rather than financial.</i> <i class="calibre5">—Peter Drucker</i> <i class="calibre5">During the years we worked on Viaweb I read a lot of job descriptions. A new competitor seemed to emerge out of the woodwork every month or so. The first thing I would do, after checking to see if they had a live online demo, was look at their job listings. After a couple years of this I could tell which companies to worry about and which not to. The more of an IT flavor the job descriptions had, the less dangerous the company was. The safest kind were the ones that wanted Oracle experience. You never had to worry about those. You were also safe if they said they wanted C++ or Java developers. If they wanted Perl or Python programmers, that would be a bit frightening —  that's starting to sound like a company where the technical side, at least, is run by real hackers.</i> <i class="calibre5">We were always very secretive about our competitive advantage of Lisp. Robert Morris says that I needn't be because even if our competitors had known, they wouldn't have understood why: “If they were that smart they'd already be programming in Lisp.”</i> <i class="calibre5">—Paul Graham, <i class="calibre5">Hackers and Painters</i></i> <p class="calibre3">I worked on a team where one of our developers spent weeks integrating an HTTP stack written in C into our C codebase. In Java or C#, this basic functionality is already there, but even if it weren't, it would take mere hours to integrate such a library.<a name="sdfootnote63anc" href="epub_split_112.html#sdfootnote63sym" id="sdfootnote63anc"><sup class="calibre7">28</sup></a>
</p>
 <p class="calibre3">For weeks after I started programming in C#, I would write code with a grin on my face, and my fellow co-workers also learning C# understood why. With a modern language, one finds that by having the system manage many of the details, more time is spent thinking about higher-level software issues.</p>
 <p class="calibre3">Sun Microsystems researchers, in a paper called “FreeTTS – A Performance Case Study”, analyzed this relationship between the productivity and performance of two speech synthesis engines — one written in Java, named FreeTTS, and one in C, named Flite:</p>
 <i class="calibre5"> When we started our study of the performance characteristics of a speech synthesis engine programmed in the Java programming language, our expectations were that it would hopefully be able to run nearly as fast as the native-C counterpart. Through using some straightforward optimizations and relying on the aggressive optimizations performed by the Java HotSpot compiler, we were pleased to find that FreeTTS runs two to four times faster than its native-C counterpart, Flite.</i> <i class="calibre5">Clearly, it would be possible for us to roll some of these optimizations back into Flite with the likely result of improving Flite's performance to levels similar to FreeTTS. The lack of Java platform features such as garbage collection and high-performance collection utilities, however, makes performing these optimizations in Flite much more time consuming from a programming point of view.</i> <p class="calibre3"><span>The programmer's time is finite and is thus the limiting factor in software engineering. One could say that the only software quality that matters is maintainability, as that gives you the time to focus on every other aspect. We need garbage collection for reliability, but the payoff is increased maintainability, which will pay for the transition costs.</span></p>
 <p class="calibre3"><span><span>Many people in the software industry no longer believe that </span></span><span>programming languages affect productivity. This misconception exists primarily because C++ didn't end up being significantly more productive than C. The debate is mostly between C and C++. Quoth Linus:</span></p>
 <i class="calibre5"> <span>Quite frankly, even if the choice of C were to do nothing but keep the C++ </span>programmers <span>out, that in itself would be a huge reason to use C.</span></i> <i class="calibre5"> C++ leads to really really bad design choices. Developers invariably start using the 'nice' library features of the language like STL and Boost and other total and utter crap, that may 'help' you program, but they cause infinite amounts of pain when they don't work and inefficient abstracted programming models.</i> <p class="calibre3">At the same time, few argue that assembly language had close to the productivity of C, so this contradiction is unresolved in the minds of many. Many computer geeks like to argue about C versus C++, but compared to a modern and elegant language like C#, this is like choosing between Britney and Paris.</p>
 <p class="calibre3"><span>While C++ added object orientation features to C, it had a fatal flaw: it was a superset of C. In fact, the early compilers just converted their code to C, which was a great way to bootstrap the new language to the many places where C was already used, but by being a superset it tied the designers to the baggage of C. While C++ added new object-oriented features, it also added significant complexity.</span><span><a name="sdfootnote64anc" href="epub_split_112.html#sdfootnote64sym" id="sdfootnote64anc"><sup class="calibre7">29</sup></a>
</span><span> </span><span><span><span>I used C++ for many years, and I liked some of the </span></span></span><span><span><span>improvements over C, but the language is mind-numbingly complicated and generally provides many more ways to screw up than in C. That  C++ didn't start with a clean slate is the second biggest mistake in the history of computing.</span></span></span></p>
 <p class="calibre3">If you could double developer productivity at the cost of half of your current performance, would you take it? There isn't any universal agreement on the answer to this question among computer engineers today. However, Moore's law states that Intel's computers take merely 18 months to become twice as fast, and in ten years, computers will be another 100 times faster than they are today. A 20% drop in performance to enable garbage collection would take Intel hardware progress 4 months to counter-balance, and we would pay it only once. Anders Hejlsberg, architect of C#, has said it is the best use of Moore's law to come around in years.</p>
 <p class="calibre3">Maintainability issues also add variability to the engineering cost of a project because developers spend an unpredictable amount of time fixing bugs. In adopting GC, developers would pay a <span>fixed performance cost in exchange for decreased engineering costs and variability.</span></p>
  	 		</body>
</html>
