<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8"/>
    <title>After The Software Wars</title>
    <meta name="AUTHOR" content="Keith Curtis"/>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/><link href="stylesheet.css" type="text/css" rel="stylesheet"/><style type="text/css">
		@page { margin-bottom: 5.000000pt; margin-top: 5.000000pt; }</style></head>
  <body dir="LTR" class="calibre">
<h2 class="calibre2" id="calibre_pb_10"><a name="1.1.Linux Kernel Superiority|outline" id="1.1.Linux Kernel Superiority|outline"></a>
 		Linux Kernel Superiority</h2> 	  <p class="calibre3"> <span>Here are the reasons Linux is superior to the Windows kernel:</span></p>
  	 		 			<h3 class="calibre9">Refactored Code (Reliability)</h3> 		 	  <p class="calibre3"> <span>Here is a diagram of the Linux kernel:</span></p>
 <p class="calibre3"> <img src="wordpress_html_mdabc9bc.png" border="0" class="calibre6"/><br class="calibre4"/>Layers of the Linux kernel “onion”. The Linux kernel is 50% device drivers, and 25% CPU-specific code. The two inner layers are very generic.</p>
 <p class="calibre3">Notice that it is built as an onion and is comprised of many discrete components. The outermost layer of the diagram is device drivers, which is 50% of the code, and more than 75% of its code is hardware-specific. The Microsoft Windows NT kernel diagram, shown several pages back, puts all the device drivers into a little box in the lower left-hand corner, illustrating the difference between theory and reality. In fact, if Microsoft had drawn the kernel mode drivers box as 50% of the Windows NT diagram, they might have understood how a kernel is mostly hardware-specific code, and reconsidered whether it was a business they wanted to get into.</p>
 <p class="calibre3">Refactoring (smoothing, refining, simplifying, polishing) is done continuously in Linux. If many drivers have similar tasks, duplicate logic can be pulled out and put into a new subsystem that can then be used by all drivers. In many cases, it isn't clear until a lot of code is written, that this new subsystem is even worthwhile. There are a number of components in the Linux kernel that evolved out of duplicate logic in multiple places. This flexible but practical approach to writing software has led Linus Torvalds to describe Linux as “Evolution, not Intelligent Design.”</p>
 <p class="calibre3">One could argue that evolution is a sign of bad design, but evolution of Linux only happens when there is a need unmet by the current software. Linux initially supported only the Intel 80386 processor because that was what Linus owned. Linux evolved, via the work of many programmers, to support additional processors —more than Windows, and more than any other operating system ever has.</p>
 <p class="calibre3"> There is also a virtuous <span>cycle </span>here: the more code gets refactored, the less likely it is that a code change will cause a regression; the more code changes don't cause regressions, the more code can be refactored. You can think about this virtuous cycle two different ways: clean code will lead to even cleaner code, and the cleaner the code, the easier it is for the system to evolve, yet still be stable. Andrew Morton has said that the Linux codebase is steadily improving in quality, even as it has tripled in size.</p>
 <p class="calibre3"> Greg Kroah-Hartman, maintainer of the USB subsystem in Linux, has told me that as USB hardware design has evolved from version 1.0 to 1.1 to 2.0 over the last decade, the device drivers and internal kernel architecture have also dramatically changed. Because all of the drivers live within the kernel, when the architecture is altered to support the new hardware requirements, the drivers can be adjusted at the same time.</p>
 <p class="calibre3"><span><span>Microsoft doesn't have a single tree with all the device drivers. Because many hardware companies have their own drivers floating around, </span></span>Microsoft is obligated to keep the old architecture around so that old code will still run. This <span><span>increases the size and complexity of the Windows kernel, slows down its development, and in some cases reveals bugs or design flaws that can't even be fixed. These </span></span><span><span>backward compatibility constraints are one of the biggest reasons Windows takes years to ship. The problem exists not just at the driver layer, but up the entire software stack. When code isn't freely available and in one place, it makes it hard to evolve. Microsoft has accumulated so much baggage over the years that it could be an airline.</span></span></p>
 <p class="calibre3">While the <i class="calibre5">internal </i>logic of Linux has evolved a lot in the last ten years, the <i class="calibre5">external</i> programmer interfaces have remained constant. The key to a stable interface is incorporating the right abstractions. One of the best abstractions that Linux adopted from Unix is the file abstraction. In order to perform almost any function on a Linux computer, from reading a web page on a remote website to downloading a picture from a camera, it is necessary to simply use the standard file commands: open and close, read and write.</p>
 <p class="calibre3">On my computer, in order to read the temperature of the CPU, I just need to open the (virtual) text file “<b class="calibre8">/proc/acpi/thermal_zone/THM0/temperature</b>” and the data I request is inside:<a name="sdfootnote6anc" href="epub_split_112.html#sdfootnote6sym" id="sdfootnote6anc"><sup class="calibre7">2</sup></a>
</p>
 <p lang="zxx" class="calibre3"> temperature:             49 C</p>
 <p class="calibre3"> In essence, the Linux kernel is a bundle of device drivers that communicate with hardware and reveal themselves as a file system. As new features, security issues, hardware requirements and scenarios confront the Linux kernel, the internal design evolves and improves, but the file system abstraction allows code outside the kernel to remain unchanged over longer periods of time.</p>
 <p class="calibre3">Here is a random sample of the change log of the Linux kernel from 2.6.14. As you can see, it is filled with all kinds of cleanup and bugfix work:</p>
 <p lang="zxx" class="calibre3"> spinlock consolidation</p>
 <p lang="zxx" class="calibre3">fix numa caused compile warnings</p>
 <p lang="zxx" class="calibre3">ntfs build fix</p>
 <p lang="zxx" class="calibre3">i8042 - use kzalloc instead of kcalloc</p>
 <p lang="zxx" class="calibre3">clean up whitespace and formatting in drivers/char/keyboard.c</p>
 <p lang="zxx" class="calibre3">s3c2410_wdt.c-state_warning.patch</p>
 <p lang="zxx" class="calibre3">[SCSI] Fix SCSI module removal/device add race</p>
 <p lang="zxx" class="calibre3">[SCSI] qla2xxx: use wwn_to_u64() transport helper</p>
 <p lang="zxx" class="calibre3">[SPARC64]: Fix mask formation in tomatillo_wsync_handler()</p>
 <p lang="zxx" class="calibre3">[ARCNET]: Fix return value from arcnet_send_packet().</p>
 <p class="calibre3">Many of the Linux kernel's code changes are polish and cleanup. Clean code is more reliable and maintainable, and reflects the pride of the free software community.</p>
 <p class="calibre3">If you look at the code changes required to make a bugfix, in the vast majority of cases all that is needed is a revision of a few lines of code in a small number of files. A general guideline Linux has for bugfixes is this: if you can't look at the code change and prove to yourself that it fixes the problem, then perhaps the underlying code is confused, and this fix shouldn't be added near the end of a release cycle.</p>
 <p class="calibre3">According to <a href="http://www.wired.com/news/linux/0,1411,66022,00.html"><span>Stanford University researchers</span></a>
, the Linux kernel has 0.17 bugs per 1,000 lines of code, 150 times <span>less t</span>han average commercial code containing 20-30 bugs per 1,000 lines.<a name="sdfootnote7anc" href="epub_split_112.html#sdfootnote7sym" id="sdfootnote7anc"><sup class="calibre7">3</sup></a>
 Microsoft's Windows bug databases aren't available on the Internet so it is impossible to make comparisons, but even if Linux isn't more reliable already, it is setup to become so because the code is simple, well-factored, and all in one place.</p>
 <p class="calibre3">Within the free software community, different teams are disparate entities, and so the idea of arbitrarily moving code from one part of the system to another can't easily happen. Inside Microsoft there are no boundaries, and so code is moved around for short-term performance gains at the cost of extra complexity.</p>
 <p class="calibre3">Here is a graph of all the function calls into the OS required to return a simple web request. These pictures demonstrate a visual difference in complexity that often exists between free and proprietary software:</p>
 <p class="calibre3"> <img src="wordpress_html_m2e72af43.jpg" border="0" class="calibre6"/><br class="calibre4"/>System call graph in Microsoft's proprietary web server, IIS.</p>
 <p class="calibre3"> <img src="wordpress_html_m1e9af381.jpg" border="0" class="calibre6"/><br class="calibre4"/>System call graph to return a picture in the free web server Apache.</p>
  	 		 			<h3 class="calibre9">Uniform Codebase (Reliability, 			Maintainability, and Usability)</h3> 		 	  <i class="calibre5">My job is to say “no”, to some extent. If you keep things clean enough and have some kind of requirement for what code can look like, you're already ahead of the game.</i> <i class="calibre5">—Linus Torvalds</i> <p class="calibre3">Linux engineers have found a way to run the same codebase on a wide variety of processors, on devices from cellphones to supercomputers, an unprecedented achievement. Linux has been tuned to first, run correctly, and then run efficiently on two, four, eight, and now 1,000 processor machines. Software has infinite malleability, so such a universal kernel has always been possible — it just took a bunch of different hardware companies working together to make it happen.</p>
 <p class="calibre3">Putting everything into one codebase helps reliability. Running the Linux kernel on a 32-processor computer shakes out multi-threaded bugs far more quickly than on a two-processor laptop. Running on low-end machines keeps the code small and simple, which makes it run faster on desktops. Features that first appear on laptops and tablets eventually trickle their way down to even smaller devices where the code undergoes even more testing and enhancement. The many hardware and server developers who want extreme reliability ensure that the kernel on my PC is as reliable as Linux's most demanding customer.</p>
 <p class="calibre3">Linux is more flexible than the Windows NT kernel, though both are very clean and flexible. For example, the National Security Agency (NSA) has created a free software component called SELinux (Security Enhancements to Linux) that adds a strong security enforcement mechanism known as Mandatory Access Control.<a name="sdfootnote8anc" href="epub_split_112.html#sdfootnote8sym" id="sdfootnote8anc"><sup class="calibre7">4</sup></a>
 Making these mechanisms public helps ensure there are no back doors to the NSA's computers. I will discuss in a later chapter why governments can adopt free software, even for high-security scenarios, but it appears the NSA already understands this concept.</p>
 <p class="calibre3">Throughout the Linux world, one has many more choices for just the right tool to do the job. Some might argue that too much choice is a bad thing, but creating many components forces clear boundaries, and survival of the fittest whittles down the inferior choices over time.</p>
  	 		 			<h3 class="calibre9">Frequent Ship Cycles (Maintainability and 			Usability)</h3> 		 	  <p class="calibre3">Microsoft had a motto: “Ship early, ship often.” This philosophy is wise for software development because it forces teams to maintain a high-quality product every day, and the earlier you release, the sooner you can receive and incorporate feedback.</p>
 <p class="calibre3">However, this philosophy only works when adopted. Unfortunately, Microsoft's two biggest products, Windows and Office, do not follow this philosophy. Of course, paying $240 every year for the latest upgrade to Windows “Ultimate” wouldn't be acceptable either!</p>
 <p class="calibre3">The Linux kernel <span>ships every three months. For</span> a product of its size and complexity, Linux's rate of shipment is unprecedented. This pace has allowed the Linux kernel to ship drivers before Windows, and even before the hardware itself has shipped. Linux supported USB 3.0 before Microsoft, which did not include it in Windows 7. Because Linux is constantly near shipping, you can take any random build from Linus' computer, put it into a rocket and feel quite confident that it won't crash.</p>
 <p class="calibre3">A big part of the Department of Justice lawsuit against Microsoft focused on the company's bundling of many software components with their operating system. The government accused Microsoft of excluding third-party software developers and stifling competition. But Microsoft's tying has been both a blessing and a curse.  </p>
 <p class="calibre3"> The blessing is that by having the pieces work together, they can reuse code and be more integrated. The curse is that Microsoft has created a situation whereby it revises and adds new features to all of its interdependent components at the same time. As a consequence, its components take years to stabilize, and you can't ship until the last component is ready.<a name="sdfootnote9anc" href="epub_split_112.html#sdfootnote9sym" id="sdfootnote9anc"><sup class="calibre7">5</sup></a>
</p>
 <p class="calibre3">By contrast, in a free OS, software components depend only on released versions. Every team doesn't try to ship on the same day, so the OS contains the latest versions of all released components.<a name="sdfootnote10anc" href="epub_split_112.html#sdfootnote10sym" id="sdfootnote10anc"><sup class="calibre7">6</sup></a>
 Separate development organizations have enforced boundaries that have simplified dependencies, and allows everyone to move ahead at whatever pace they choose.</p>
 <p class="calibre3">Many users wonder whether free software will ever be as good as proprietary software because presumably the free software guys can't afford things like usability studies. Having watched usability studies at Microsoft, grabbing people off the street to give their bits of feedback in a room with two-way mirrors is not necessary. The Internet, and all its communications mechanisms, provides a continuous and richer feedback mechanism than you can get with any usability study. In addition, usability studies don't matter if you can't incorporate the changes quickly and easily. With clean codebases and frequent ship cycles, usability will happen automatically. I've spent a lot of time using Linux and find many applications are perfectly usable.</p>
 <p class="calibre3">Shipping a new platform every five years in theory provides Microsoft's partners a stable platform upon which to build. However, in reality, its results have flaws. For instance, I wasn't able to install an HP Photodesk 7960 printer driver on Windows<span> Server </span>2003, although the driver installed perfectly on XP. The subtle and unintentionally undocumented differences between those operating systems, which shipped two years apart, has created compatibility headaches even on Microsoft's supposedly uniform platform.</p>
  	 		 			<h3 class="calibre9">Lower Development Costs (Maintainability)</h3> 		 	  <p class="calibre3">It is much less expensive for hardware vendors to support Linux. If you want to build a device driver, a great place to start is by looking at existing shipping device drivers, an opportunity that Linux offers to everyone. A proprietary “Device Driver Toolkit” with its sample code is never as good as production code. Those expensive kits contain documentation, but not source code — so you sometimes have to guess at what is happening down below.</p>
 <p class="calibre3">We find in Windows today that hardware manufacturers have duplicated a bunch of the functionality Windows provides but doesn't quite fit their needs. For example, IBM includes its own applet and status icon for wireless Internet, so Windows XP on IBM hardware has two. Presumably they weren't satisfied with the features Windows provided, and weren't able to fix them. And so they had to build new applets from scratch! This is also what gives Windows a feeling of a jumble of components slapped together.</p>
 <p class="calibre3">Here are five of the 100 applets IBM adds to Windows:</p>
 <p class="calibre3"> <img src="wordpress_html_664c43b0.png" border="0" class="calibre6"/><br class="calibre4"/>Windows XP with 5 of IBM's 100 extra applets. Notice the large number of status icons on this almost-virgin installation.</p>
 <p class="calibre3">Building all of these applets, designing multilingual user interfaces, providing the means to install and configure, etc. is ten<span> times more work </span>than merely writing the device driver, leveraging other shipping drivers, and uploading it to the official codebase.</p>
 <p class="calibre3">My Photodesk 7960 printer worked on Windows XP, but didn't work on Windows Server 2003 because the installation code crashed — which HP shouldn't be forced to bother with in the first place.</p>
  	 		 			<h3 class="calibre9"> 			Security (Reliability and Maintainability)</h3> 		 	  <i class="calibre5">To mess up a Linux box, you need to work <i class="calibre5"><span>at </span></i>it; to mess up your Windows box, you just need to work <i class="calibre5"><span>on</span></i> it.</i> <i class="calibre5"> —<a href="http://www.theregister.co.uk/2003/10/06/linux_vs_windows_viruses/"><span>Scott Granneman</span></a>
</i> <p class="calibre3">Attempting to compare the security of operating systems is a complicated endeavor because there are an infinite number of risks. It is like asking whether one car is safer than another. Against what: Getting hit from the front? Rolling over? Having the gas tank pierced? Its ability to brake?</p>
 <p class="calibre3">Furthermore, neither Windows nor Linux are perfectly secure operating systems; both are prone to buffer-overrun viruses, an issue I will discuss in the tools chapter. Furthermore, new threats appear over time, and so each nefarious advancement requires new logic to defend against it. Given these caveats, it is still possible to make some comparisons.</p>
 <p class="calibre3">Some of the previous advantages of Linux, such as its simplicity, modularity, support for SELinux, etc. all help with its security. In addition, the nature of how Linux is developed also helps. A document commissioned by the US Military said:</p>
 <i class="calibre5"><b class="calibre8">Open source software is potentially subject to scrutiny by many eyes</b></i> <i class="calibre5">Therefore bugs, security flaws, and poor design cannot hide for long, at least when the software has a community of programmers to support it. And since fixing the code doesn't depend on a single vendor, patches are often distributed much more rapidly than patches to closed source software.</i> <i class="calibre5"><b class="calibre8">Can increase code quality and security</b></i> <i class="calibre5">With closed source software, it's often difficult to evaluate the quality and security of the code. In addition, closed source software companies have an incentive to delay announcing security flaws or bugs in their product. Often this means that their customers don't learn of security flaws until weeks or months after the security exploit was known internally.</i> <i class="calibre5">—<a href="http://www.acq.osd.mil/jctd/articles/OTDRoadmapFinal.pdf"><span>Open Technology Development Roadmap</span></a>
</i> <p class="calibre3">Another big difference between Linux and Windows is that Linux was adapted from Unix, which had a multiuser design right from the beginning. In Windows, users have historically had full Administrator access to the machine, including the ability to overwrite system files. When the computer is attacked by a virus, the virus can gain the same capabilities as the user and thereby hide itself inside system files, which make it very difficult to remove. On Linux, I can write only to my own files and have read-only access to all others. Linux's multiuser nature, and therefore its focus on minimal permissions, minimizes any damage.  </p>
 <p class="calibre3">One study found that there are about 60,000 known viruses for Windows, and only about 40 for Linux. Another study by <i class="calibre5">Evans Data</i> <a href="http://www.crn.com.au/News/15829,linux-hacks-rare-as-hens-teeth-says-survey.aspx"><span>showed</span></a>
 that 8% of Linux developers say their machines have been infected by malicious code, compared to 60% of Windows machines.</p>
 <p class="calibre3">Brian Krebs of the <i class="calibre5">Washington Post</i>  <a href="http://blog.washingtonpost.com/securityfix/2007/01/internet_explorer_unsafe_for_2.html"><span>found</span></a>
 that code to exploit flaws in Internet Explorer 6 existed for 284 days in 2006, while Firefox was at risk for just 9. <span>Computer security expert Bruce Schneier </span><a href="http://www.schneier.com/blog/archives/2004/12/safe_personal_c.html"><span><span>recommended</span></span></a>
<span> in December 2004 that people not run Internet </span><span>Explorer. </span>Some argue that Linux and Firefox have fewer viruses because they have fewer users, but Apache is well-respected for its security.</p>
 <p class="calibre3">For most of my tenure at Microsoft, we worried about features, reliability, and performance, not security. Microsoft's Chief Research and Strategy Officer, Craig Mundie, <a href="http://www.vnunet.com/vnunet/news/2120337/microsoft-outlines-security-strategy"><span><span>said</span></span></a>
 in 2002:</p>
 <i class="calibre5">Many of the products we designed in the past have been less secure than they could have been because we were designing with features in mind rather than security.</i> <p class="calibre3">Microsoft has greatly increased its focus on security in the past few years, and I am sure the security of every product improves with every release, but the <a href="http://weblog.infoworld.com/enterprisemac/archives/2006/08/is_windows_inhe.html"><span>baggage</span></a>
 of their codebases serve as an ongoing impediment.</p>
 <p class="calibre3">Having browsed through the sources to a number of Linux applications, one can say the free codebases are typically cleaner than their Windows counterparts, which makes them easier to secure. The default server-oriented Debian 4.0 Linux distribution requires a mere 170MB of disk space, whereas Windows Server 2003 requires 3 GB. All other things being equal, the fact that Debian is 17 times smaller means it will be more secure. The free database <span>MySQL </span>is a mere 26MB download; the code is clean and small, and therefore much more likely to be reliable and secure.</p>
 <p class="calibre3">Another advantage of Linux is that <span>all </span>the applications in a Linux operating system receive security updates. In the Microsoft world, <span>only Microsoft's code is protected by Windows Update</span>.</p>
 <p class="calibre3">While Linux is free to acquire, it can also be cheaper to run and maintain than Windows because of its better security. The city of Manchester in England <a href="http://www.manchestereveningnews.co.uk/news/s/1121846_bus_lane_fines_axed_over_bug?rss=yes">spent</a>
 $2 million in 2009 to remove the Conficker worm from their computers.</p>
  	 		 			<h3 class="calibre9">Linux has learned from Windows</h3> 		 	  <p class="calibre3">While the Windows NT kernel was state of the art at the time it was released in 1993, most of its good ideas have been learned well and absorbed, in spite of the fact that the code has never been released.</p>
 <p class="calibre3">For example, the Linux kernel supports asynchronous I/O (input/output), an innovative way to do reads and writes without tying up “thread” resources. This was an innovation first made widespread in Windows NT.</p>
 <p class="calibre3">The ability to load code dynamically is another important feature the Linux kernel adopted from NT and others. Plug and play and suspend and hibernate was a collaboration between Microsoft and hardware companies in the 1990s, and Linux now supports this feature.</p>
 <p class="calibre3">Throughout the free software stack, developers have incorporated good ideas from the outside world. There is no Not Invented Here syndrome in free software; a good idea is a good idea, and existing code is even better. In software today, the biggest impediment to sharing ideas is not ego, but license agreements.</p>
 <p class="calibre3">The Linux kernel has even learned from Microsoft's mistakes. For example, one feature added to the Windows NT 4.0 kernel was to put the code that draws widgets into the kernel <span>itself</span>. While this can improve graphics performance, it also means that a bug in the code of a button has the capacity to crash the entire system. The best way to keep a system secure and reliable is to keep as much code as possible in user mode above the kernel, and Linux follows this strategy.<a name="sdfootnote11anc" href="epub_split_112.html#sdfootnote11sym" id="sdfootnote11anc"><sup class="calibre7">7</sup></a>
</p>
 </body>
</html>
